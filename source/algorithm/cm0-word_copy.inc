// Generated by vscode-hexdump
//
// Hand decompiled M4 code.  C code sets up registers thusly:
// R0 - length of data to be flashed in bytes
// R1 - 0x20002ff8 - points to the ring buffer write and read pointers
// R2 - 0x20004000 - end of SRAM buffer
// R3 - 0x00000000 - first byte of flash
//
// This code deals with 32 bits at a time and though the length in R0 is in bytes, there must be at least 4 bytes in the buffer
//
//  PC    Opcode          Disassembly
//   0:   680d            ldr     r5, [r1, #0]	; R5 contains the ring buffer write pointer
//   2:   2d00            cmp     r5, #0
//   4:   d00b            beq.n   0x1e			; if null we are done
//   6:   684c            ldr     r4, [r1, #4]	; r4 contains the ring buffer read pointer
//   8:   42ac            cmp     r4, r5		; if ring buffer read and write pointers are the same, we have no data
//   a:   d0f9            beq.n   0x0			; go back and wait for data
//   c:   cc20            ldmia   r4!, {r5}		; copy from ring buffer read pointer to destination using r5 as temp storage
//   e:   c320            stmia   r3!, {r5}
//  10:   4294            cmp     r4, r2		; if the ring buffer read pointer is less than the end of ring buffer, continue
//  12:   d301            bcc.n   0x18			; branch if r4 < r2
//  14:   460c            mov     r4, r1		; save pointer to ring buffer read/write pointer structure in R4
//  16:   3408            adds    r4, #8		; point r4 back at the beginning of the ring buffer
//  18:   604c            str     r4, [r1, #4]	; update the ring buffer read pointer
//  1a:   3804            subs    r0, #4		; reduce the length of data remaining by 4 bytes
//  1c:   d1f0            bne.n   0x0			; if more data continue
//  1e:   be00            bkpt    0x0000		; trigger a breakpoint exception

0x0d, 0x68, 0x00, 0x2d, 0x0b, 0xd0, 0x4c, 0x68,
0xac, 0x42, 0xf9, 0xd0, 0x20, 0xcc, 0x20, 0xc3,
0x94, 0x42, 0x01, 0xd3, 0x0c, 0x46, 0x08, 0x34,
0x4c, 0x60, 0x04, 0x38, 0xf0, 0xd1, 0x00, 0xbe,
